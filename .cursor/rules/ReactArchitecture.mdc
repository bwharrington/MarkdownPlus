---
description: React/TypeScript best practices for modular components, styled-components, and type safety
globs: **/*.{ts,tsx}
alwaysApply: false
---

# Best Practices for React/TypeScript Projects

This document outlines key best practices for building React applications with TypeScript, emphasizing modular and small components, the use of styled-components for styling, and additional recommendations drawn from recent industry insights as of 2026. These practices aim to enhance code maintainability, scalability, performance, and type safety.

## 1. Project Structure
A solid folder structure promotes modularity and easier navigation.

- **Folder Structure Best Practices**:
  - Organize by feature or domain (e.g., `/features/user`, `/features/auth`) rather than by type (e.g., avoiding separate folders for all components, hooks, etc.).
  - Use absolute imports via `tsconfig.json` or `jsconfig.json` to avoid relative path hell (e.g., `import { Button } from '@components/Button'`).
  - Avoid deep nesting beyond 2-3 levels in folders.
  - Include directories like `/src/components` for reusable UI, `/src/hooks` for custom hooks, `/src/utils` for utilities, and `/src/types` for shared TypeScript types.

## 2. Component Design: Modular and Small Components
Keep components focused, reusable, and composable. Aim for the Single Responsibility Principle (SRP) where each component handles one concern.

- **Small Components**: Break down large components into smaller ones. For example, instead of a monolithic `UserProfile` component, split into `UserAvatar`, `UserInfo`, and `UserActions`. This improves readability and testability.
- **Modular Approach**: Use composition over inheritance. Leverage patterns like Compound Components for flexible UIs (e.g., a `Select` component with `Option` sub-components).
- **Hooks for Logic Separation**: Extract logic into custom hooks (e.g., `useUserData()`) to keep components declarative and focused on rendering.
- **Prop Drilling Avoidance**: Use Context API or state management libraries like Zustand/Recoil for global state, but sparingly—prefer prop passing for local state.
- **Patterns for Better Code**: Implement Render Props, Higher-Order Components (HOCs), or Hooks for reusability. For conditional rendering, use early returns instead of ternary operators for clarity.

```typescript
// ❌ BAD - Monolithic component
const UserProfile = () => {
  // 200 lines of mixed logic and UI
}

// ✅ GOOD - Composed from smaller pieces
const UserProfile = () => (
  <>
    <UserAvatar />
    <UserInfo />
    <UserActions />
  </>
)
```

## 3. Using Styled-Components
Styled-components is a popular CSS-in-JS library for React, allowing scoped styles and theme integration. Follow these practices for efficient usage.

- **Define Styles Outside Render**: Always define styled components outside the render method or function body to prevent re-creation on every render, which can hurt performance.
- **Component-Based Styling**: Create styled wrappers for primitives (e.g., `const Button = styled.button``) and compose them. Use props for dynamic styling (e.g., `background: ${props => props.primary ? 'blue' : 'gray'};`).
- **Theming**: Implement a `ThemeProvider` at the app root for consistent theming. Define themes in a separate file (e.g., `themes.ts`) with TypeScript interfaces for type safety (e.g., `interface Theme { colors: { primary: string; } }`).
- **Best Practices**:
  - Colocate styles with components for better maintainability, but extract shared styles to a global file if needed.
  - Use `attrs` for adding attributes dynamically (e.g., `styled.input.attrs({ type: 'password' })``).
  - Avoid global styles; prefer component-scoped CSS to prevent conflicts.
  - For performance, minimize style injections by reusing styled components and using `shouldForwardProp` to filter unnecessary props.
  - Integrate with TypeScript: Extend `DefaultTheme` in your `styled.d.ts` file for autocomplete on theme props.
- **Happy Path Suite**: Use a consistent naming convention (e.g., `StyledButton`), and leverage extensions like `styled(Button)`` for inheritance. Consider alternatives like Emotion if server-side rendering is critical, but styled-components works well with proper setup.

```typescript
// ❌ BAD - Defined inside component
const MyComponent = () => {
  const Button = styled.button`...`;
  return <Button />;
}

// ✅ GOOD - Defined outside
const StyledButton = styled.button<{ primary?: boolean }>`
  background: ${props => props.primary ? 'blue' : 'gray'};
`;

const MyComponent = () => <StyledButton primary />;
```

## 4. TypeScript-Specific Best Practices
TypeScript enhances React by providing static type checking, reducing runtime errors.

- **Type Safety First**: Use explicit types for props, state, and hooks. For components, prefer `React.FC<Props>` or function declarations with typed props (e.g., `const MyComponent: React.FC<{ name: string }> = ({ name }) => ...`).
- **Leverage Inference**: Let TypeScript infer types where possible (e.g., for simple variables), but annotate complex ones. Use utility types like `Partial<T>`, `Pick<T, K>`, and `Omit<T, K>` for flexible props.
- **Advanced Features**: Utilize TypeScript 5.6+ features like improved error messages for JSX and better inference for generics in React components.
- **Typing Hooks and Contexts**: Create typed hooks (e.g., `useState<string>('')`) and contexts with `createContext<MyType | null>(null)`. Use `as const` for literal types.
- **Avoid `any`**: Strive for no `any` types; use `unknown` when uncertain and narrow types safely.

```typescript
// ✅ GOOD - Explicit prop types
interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
}

const Button: React.FC<ButtonProps> = ({ label, onClick, variant = 'primary' }) => {
  return <button onClick={onClick}>{label}</button>;
}
```

## 5. Additional Best Practices
- **State Management**: For complex apps, use Redux Toolkit or Zustand with TypeScript slices for type-safe actions and reducers. Prefer local state with `useState` and `useReducer` for simpler cases.
- **Performance Optimization**: Memoize components with `React.memo` and hooks with `useMemo`/`useCallback`. Use lazy loading with `React.lazy` and Suspense for code splitting.
- **Testing**: Write unit tests with Jest and React Testing Library. Focus on behavior over implementation (e.g., test user interactions).
- **Accessibility (a11y)**: Use semantic HTML, ARIA attributes, and tools like eslint-plugin-jsx-a11y. Ensure keyboard navigation and screen reader compatibility.
- **Security**: Sanitize inputs, use HTTPS, and avoid inline scripts. For auth, integrate libraries like React Query with secure token handling.
- **Code Quality**: Enforce linting with ESLint (react/recommended + typescript-eslint), formatting with Prettier, and type checking in CI/CD pipelines.
- **Deployment and Monitoring**: Use Vercel or Netlify for easy deploys. Monitor with tools like Sentry for error tracking.

By following these practices, your React/TypeScript projects will be more robust, maintainable, and efficient. Always stay updated with the React and TypeScript docs for evolving features.
