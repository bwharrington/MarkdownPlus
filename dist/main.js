/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/dotenv/lib/main.js":
/*!*****************************************!*\
  !*** ./node_modules/dotenv/lib/main.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst os = __webpack_require__(/*! os */ \"os\")\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\")\nconst packageJson = __webpack_require__(/*! ../package.json */ \"./node_modules/dotenv/package.json\")\n\nconst version = packageJson.version\n\n// Array of tips to display randomly\nconst TIPS = [\n  'üîê encrypt with Dotenvx: https://dotenvx.com',\n  'üîê prevent committing .env to code: https://dotenvx.com/precommit',\n  'üîê prevent building .env in docker: https://dotenvx.com/prebuild',\n  'üì° add observability to secrets: https://dotenvx.com/ops',\n  'üë• sync secrets across teammates & machines: https://dotenvx.com/ops',\n  'üóÇÔ∏è backup and recover secrets: https://dotenvx.com/ops',\n  '‚úÖ audit secrets and track compliance: https://dotenvx.com/ops',\n  'üîÑ add secrets lifecycle management: https://dotenvx.com/ops',\n  'üîë add access controls to secrets: https://dotenvx.com/ops',\n  'üõ†Ô∏è  run anywhere with `dotenvx run -- yourcommand`',\n  '‚öôÔ∏è  specify custom .env file path with { path: \\'/custom/path/.env\\' }',\n  '‚öôÔ∏è  enable debug logging with { debug: true }',\n  '‚öôÔ∏è  override existing env vars with { override: true }',\n  '‚öôÔ∏è  suppress all logs with { quiet: true }',\n  '‚öôÔ∏è  write to custom object with { processEnv: myObject }',\n  '‚öôÔ∏è  load multiple .env files with { path: [\\'.env.local\\', \\'.env\\'] }'\n]\n\n// Get a random tip from the tips array\nfunction _getRandomTip () {\n  return TIPS[Math.floor(Math.random() * TIPS.length)]\n}\n\nfunction parseBoolean (value) {\n  if (typeof value === 'string') {\n    return !['false', '0', 'no', 'off', ''].includes(value.toLowerCase())\n  }\n  return Boolean(value)\n}\n\nfunction supportsAnsi () {\n  return process.stdout.isTTY // && process.env.TERM !== 'dumb'\n}\n\nfunction dim (text) {\n  return supportsAnsi() ? `\\x1b[2m${text}\\x1b[0m` : text\n}\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parse src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _parseVault (options) {\n  options = options || {}\n\n  const vaultPath = _vaultPath(options)\n  options.path = vaultPath // parse .env.vault\n  const result = DotenvModule.configDotenv(options)\n  if (!result.parsed) {\n    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)\n    err.code = 'MISSING_DATA'\n    throw err\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n  const keys = _dotenvKey(options).split(',')\n  const length = keys.length\n\n  let decrypted\n  for (let i = 0; i < length; i++) {\n    try {\n      // Get full key\n      const key = keys[i].trim()\n\n      // Get instructions for decrypt\n      const attrs = _instructions(result, key)\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)\n\n      break\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted)\n}\n\nfunction _warn (message) {\n  console.error(`[dotenv@${version}][WARN] ${message}`)\n}\n\nfunction _debug (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}] ${message}`)\n}\n\nfunction _dotenvKey (options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n    return process.env.DOTENV_KEY\n  }\n\n  // fallback to empty string\n  return ''\n}\n\nfunction _instructions (result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  let uri\n  try {\n    uri = new URL(dotenvKey)\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    }\n\n    throw error\n  }\n\n  // Get decrypt key\n  const key = uri.password\n  if (!key) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing key part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get environment\n  const environment = uri.searchParams.get('environment')\n  if (!environment) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get ciphertext payload\n  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`\n  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)\n    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'\n    throw err\n  }\n\n  return { ciphertext, key }\n}\n\nfunction _vaultPath (options) {\n  let possibleVaultPath = null\n\n  if (options && options.path && options.path.length > 0) {\n    if (Array.isArray(options.path)) {\n      for (const filepath of options.path) {\n        if (fs.existsSync(filepath)) {\n          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`\n        }\n      }\n    } else {\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`\n    }\n  } else {\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')\n  }\n\n  if (fs.existsSync(possibleVaultPath)) {\n    return possibleVaultPath\n  }\n\n  return null\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\nfunction _configVault (options) {\n  const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || (options && options.debug))\n  const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || (options && options.quiet))\n\n  if (debug || !quiet) {\n    _log('Loading env from encrypted .env.vault')\n  }\n\n  const parsed = DotenvModule._parseVault(options)\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsed, options)\n\n  return { parsed }\n}\n\nfunction configDotenv (options) {\n  const dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n  let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || (options && options.debug))\n  let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || (options && options.quiet))\n\n  if (options && options.encoding) {\n    encoding = options.encoding\n  } else {\n    if (debug) {\n      _debug('No encoding is specified. UTF-8 is used by default')\n    }\n  }\n\n  let optionPaths = [dotenvPath] // default, look for .env\n  if (options && options.path) {\n    if (!Array.isArray(options.path)) {\n      optionPaths = [_resolveHome(options.path)]\n    } else {\n      optionPaths = [] // reset default\n      for (const filepath of options.path) {\n        optionPaths.push(_resolveHome(filepath))\n      }\n    }\n  }\n\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\n  let lastError\n  const parsedAll = {}\n  for (const path of optionPaths) {\n    try {\n      // Specifying an encoding returns a string instead of a buffer\n      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))\n\n      DotenvModule.populate(parsedAll, parsed, options)\n    } catch (e) {\n      if (debug) {\n        _debug(`Failed to load ${path} ${e.message}`)\n      }\n      lastError = e\n    }\n  }\n\n  const populated = DotenvModule.populate(processEnv, parsedAll, options)\n\n  // handle user settings DOTENV_CONFIG_ options inside .env file(s)\n  debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug)\n  quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet)\n\n  if (debug || !quiet) {\n    const keysCount = Object.keys(populated).length\n    const shortPaths = []\n    for (const filePath of optionPaths) {\n      try {\n        const relative = path.relative(process.cwd(), filePath)\n        shortPaths.push(relative)\n      } catch (e) {\n        if (debug) {\n          _debug(`Failed to load ${filePath} ${e.message}`)\n        }\n        lastError = e\n      }\n    }\n\n    _log(`injecting env (${keysCount}) from ${shortPaths.join(',')} ${dim(`-- tip: ${_getRandomTip()}`)}`)\n  }\n\n  if (lastError) {\n    return { parsed: parsedAll, error: lastError }\n  } else {\n    return { parsed: parsedAll }\n  }\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options)\n  }\n\n  const vaultPath = _vaultPath(options)\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!vaultPath) {\n    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)\n\n    return DotenvModule.configDotenv(options)\n  }\n\n  return DotenvModule._configVault(options)\n}\n\nfunction decrypt (encrypted, keyStr) {\n  const key = Buffer.from(keyStr.slice(-64), 'hex')\n  let ciphertext = Buffer.from(encrypted, 'base64')\n\n  const nonce = ciphertext.subarray(0, 12)\n  const authTag = ciphertext.subarray(-16)\n  ciphertext = ciphertext.subarray(12, -16)\n\n  try {\n    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)\n    aesgcm.setAuthTag(authTag)\n    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`\n  } catch (error) {\n    const isRange = error instanceof RangeError\n    const invalidKeyLength = error.message === 'Invalid key length'\n    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'\n\n    if (isRange || invalidKeyLength) {\n      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    } else if (decryptionFailed) {\n      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')\n      err.code = 'DECRYPTION_FAILED'\n      throw err\n    } else {\n      throw error\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate (processEnv, parsed, options = {}) {\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n  const populated = {}\n\n  if (typeof parsed !== 'object') {\n    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')\n    err.code = 'OBJECT_REQUIRED'\n    throw err\n  }\n\n  // Set process.env\n  for (const key of Object.keys(parsed)) {\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key]\n        populated[key] = parsed[key]\n      }\n\n      if (debug) {\n        if (override === true) {\n          _debug(`\"${key}\" is already defined and WAS overwritten`)\n        } else {\n          _debug(`\"${key}\" is already defined and was NOT overwritten`)\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key]\n      populated[key] = parsed[key]\n    }\n  }\n\n  return populated\n}\n\nconst DotenvModule = {\n  configDotenv,\n  _configVault,\n  _parseVault,\n  config,\n  decrypt,\n  parse,\n  populate\n}\n\nmodule.exports.configDotenv = DotenvModule.configDotenv\nmodule.exports._configVault = DotenvModule._configVault\nmodule.exports._parseVault = DotenvModule._parseVault\nmodule.exports.config = DotenvModule.config\nmodule.exports.decrypt = DotenvModule.decrypt\nmodule.exports.parse = DotenvModule.parse\nmodule.exports.populate = DotenvModule.populate\n\nmodule.exports = DotenvModule\n\n\n//# sourceURL=webpack://markdownplus/./node_modules/dotenv/lib/main.js?");

/***/ }),

/***/ "./node_modules/dotenv/package.json":
/*!******************************************!*\
  !*** ./node_modules/dotenv/package.json ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"name\":\"dotenv\",\"version\":\"17.2.4\",\"description\":\"Loads environment variables from .env file\",\"main\":\"lib/main.js\",\"types\":\"lib/main.d.ts\",\"exports\":{\".\":{\"types\":\"./lib/main.d.ts\",\"require\":\"./lib/main.js\",\"default\":\"./lib/main.js\"},\"./config\":\"./config.js\",\"./config.js\":\"./config.js\",\"./lib/env-options\":\"./lib/env-options.js\",\"./lib/env-options.js\":\"./lib/env-options.js\",\"./lib/cli-options\":\"./lib/cli-options.js\",\"./lib/cli-options.js\":\"./lib/cli-options.js\",\"./package.json\":\"./package.json\"},\"scripts\":{\"dts-check\":\"tsc --project tests/types/tsconfig.json\",\"lint\":\"standard\",\"pretest\":\"npm run lint && npm run dts-check\",\"test\":\"tap run tests/**/*.js --allow-empty-coverage --disable-coverage --timeout=60000\",\"test:coverage\":\"tap run tests/**/*.js --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov\",\"prerelease\":\"npm test\",\"release\":\"standard-version\"},\"repository\":{\"type\":\"git\",\"url\":\"git://github.com/motdotla/dotenv.git\"},\"homepage\":\"https://github.com/motdotla/dotenv#readme\",\"funding\":\"https://dotenvx.com\",\"keywords\":[\"dotenv\",\"env\",\".env\",\"environment\",\"variables\",\"config\",\"settings\"],\"readmeFilename\":\"README.md\",\"license\":\"BSD-2-Clause\",\"devDependencies\":{\"@types/node\":\"^18.11.3\",\"decache\":\"^4.6.2\",\"sinon\":\"^14.0.1\",\"standard\":\"^17.0.0\",\"standard-version\":\"^9.5.0\",\"tap\":\"^19.2.0\",\"typescript\":\"^4.8.4\"},\"engines\":{\"node\":\">=12\"},\"browser\":{\"fs\":false}}');\n\n//# sourceURL=webpack://markdownplus/./node_modules/dotenv/package.json?");

/***/ }),

/***/ "./src/main/aiIpcHandlers.ts":
/*!***********************************!*\
  !*** ./src/main/aiIpcHandlers.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.registerAIIpcHandlers = registerAIIpcHandlers;\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst path = __importStar(__webpack_require__(/*! path */ \"path\"));\nconst fs = __importStar(__webpack_require__(/*! fs/promises */ \"fs/promises\"));\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/main/logger.ts\");\nconst xaiApi_1 = __webpack_require__(/*! ./services/xaiApi */ \"./src/main/services/xaiApi.ts\");\nconst claudeApi_1 = __webpack_require__(/*! ./services/claudeApi */ \"./src/main/services/claudeApi.ts\");\nconst openaiApi_1 = __webpack_require__(/*! ./services/openaiApi */ \"./src/main/services/openaiApi.ts\");\n// System prompt for AI edit mode - instructs AI to return JSON\nconst DIFF_EDIT_SYSTEM_PROMPT = `You are helping edit a markdown document. The user will provide the current document content and request specific changes.\r\n\r\nRULES:\r\n1. Return a JSON object with \"modifiedContent\" (the complete modified document) and \"summary\" (brief description of changes)\r\n2. Preserve all content that the user did not ask to change\r\n3. Maintain the exact formatting, indentation, and line endings of unchanged sections\r\n4. Make ONLY the changes the user explicitly requested\r\n5. The modifiedContent must be the complete document, not a partial diff\r\n6. Your response MUST be valid JSON and nothing else\r\n\r\nExample response format:\r\n{\r\n  \"modifiedContent\": \"# Title\\\\n\\\\nUpdated content here...\",\r\n  \"summary\": \"Added a new section about X and fixed typo in paragraph 2\"\r\n}`;\n// Helper function to load config and filter enabled models\nfunction getEnabledModels(provider, allModels) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const configPath = path.join(electron_1.app.getPath('userData'), 'config.json');\n            const data = yield fs.readFile(configPath, 'utf-8');\n            const config = JSON.parse(data);\n            // If no aiModels config exists, return all models (default behavior)\n            if (!config.aiModels || !config.aiModels[provider]) {\n                return allModels;\n            }\n            // Filter models based on enabled flag in config\n            const enabledModels = allModels.filter(model => {\n                const modelConfig = config.aiModels[provider][model.id];\n                // If model not in config or explicitly enabled, include it\n                return !modelConfig || modelConfig.enabled !== false;\n            });\n            (0, logger_1.log)(`Filtered ${provider} models`, { total: allModels.length, enabled: enabledModels.length });\n            return enabledModels;\n        }\n        catch (error) {\n            // If config can't be read, return all models\n            (0, logger_1.logError)(`Failed to load config for filtering ${provider} models, returning all`, error);\n            return allModels;\n        }\n    });\n}\nfunction registerAIIpcHandlers() {\n    (0, logger_1.log)('Registering AI IPC handlers');\n    // xAI Chat Request\n    electron_1.ipcMain.handle('ai:chat-request', (_event, data) => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('AI IPC: chat-request', { model: data.model, messageCount: data.messages.length });\n        try {\n            const response = yield (0, xaiApi_1.callXAiApi)(data.messages, data.model);\n            return { success: true, response };\n        }\n        catch (error) {\n            (0, logger_1.logError)('AI IPC: chat-request failed', error);\n            return { success: false, error: error.message };\n        }\n    }));\n    // Claude Chat Request\n    electron_1.ipcMain.handle('ai:claude-chat-request', (_event, data) => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('AI IPC: claude-chat-request', { model: data.model, messageCount: data.messages.length });\n        try {\n            const response = yield (0, claudeApi_1.callClaudeApi)(data.messages, data.model);\n            return { success: true, response };\n        }\n        catch (error) {\n            (0, logger_1.logError)('AI IPC: claude-chat-request failed', error);\n            return { success: false, error: error.message };\n        }\n    }));\n    // List xAI Models\n    electron_1.ipcMain.handle('ai:list-models', () => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('AI IPC: list-models');\n        try {\n            const models = yield (0, xaiApi_1.listModels)();\n            const modelOptions = models.map(m => ({\n                id: m.id,\n                displayName: formatModelName(m.id),\n            }));\n            const enabledModels = yield getEnabledModels('xai', modelOptions);\n            return { success: true, models: enabledModels };\n        }\n        catch (error) {\n            (0, logger_1.logError)('AI IPC: list-models failed, using defaults', error);\n            // Return default models on error\n            const enabledModels = yield getEnabledModels('xai', xaiApi_1.DEFAULT_XAI_MODELS);\n            return { success: true, models: enabledModels };\n        }\n    }));\n    // List Claude Models\n    electron_1.ipcMain.handle('ai:list-claude-models', () => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('AI IPC: list-claude-models');\n        try {\n            const models = yield (0, claudeApi_1.listClaudeModels)();\n            const modelOptions = models.map(m => ({\n                id: m.id,\n                displayName: m.display_name || formatModelName(m.id),\n            }));\n            const enabledModels = yield getEnabledModels('claude', modelOptions);\n            return { success: true, models: enabledModels };\n        }\n        catch (error) {\n            (0, logger_1.logError)('AI IPC: list-claude-models failed, using defaults', error);\n            // Return default models on error\n            const enabledModels = yield getEnabledModels('claude', claudeApi_1.DEFAULT_CLAUDE_MODELS);\n            return { success: true, models: enabledModels };\n        }\n    }));\n    // OpenAI Chat Request\n    electron_1.ipcMain.handle('ai:openai-chat-request', (_event, data) => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('AI IPC: openai-chat-request', { model: data.model, messageCount: data.messages.length });\n        try {\n            const response = yield (0, openaiApi_1.callOpenAIApi)(data.messages, data.model);\n            return { success: true, response };\n        }\n        catch (error) {\n            (0, logger_1.logError)('AI IPC: openai-chat-request failed', error);\n            return { success: false, error: error.message };\n        }\n    }));\n    // List OpenAI Models\n    electron_1.ipcMain.handle('ai:list-openai-models', () => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('AI IPC: list-openai-models');\n        try {\n            const models = yield (0, openaiApi_1.listOpenAIModels)();\n            const modelOptions = models.map(m => ({\n                id: m.id,\n                displayName: formatModelName(m.id),\n            }));\n            const enabledModels = yield getEnabledModels('openai', modelOptions);\n            return { success: true, models: enabledModels };\n        }\n        catch (error) {\n            (0, logger_1.logError)('AI IPC: list-openai-models failed, using defaults', error);\n            // Return default models on error\n            const enabledModels = yield getEnabledModels('openai', openaiApi_1.DEFAULT_OPENAI_MODELS);\n            return { success: true, models: enabledModels };\n        }\n    }));\n    // AI Edit Request (structured output for Claude and OpenAI only)\n    electron_1.ipcMain.handle('ai:edit-request', (_event, data) => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('AI IPC: edit-request', { provider: data.provider, model: data.model, messageCount: data.messages.length });\n        // xAI not supported for edit mode\n        if (data.provider === 'xai') {\n            return {\n                success: false,\n                error: 'Edit mode is not supported with xAI. Please switch to Claude or OpenAI.'\n            };\n        }\n        try {\n            let response;\n            if (data.provider === 'claude') {\n                // Claude with system prompt\n                const claudeMessages = data.messages.map(m => ({\n                    role: m.role,\n                    content: m.content,\n                }));\n                response = yield (0, claudeApi_1.callClaudeApiWithSystemPrompt)(claudeMessages, DIFF_EDIT_SYSTEM_PROMPT, data.model);\n            }\n            else if (data.provider === 'openai') {\n                // OpenAI with JSON mode\n                const openaiMessages = [\n                    { role: 'system', content: DIFF_EDIT_SYSTEM_PROMPT },\n                    ...data.messages\n                ];\n                response = yield (0, openaiApi_1.callOpenAIApiWithJsonMode)(openaiMessages, data.model);\n            }\n            else {\n                return { success: false, error: `Unknown provider: ${data.provider}` };\n            }\n            // Parse JSON response\n            try {\n                // Handle potential markdown code fences\n                let jsonStr = response.trim();\n                if (jsonStr.startsWith('```json')) {\n                    jsonStr = jsonStr.slice(7);\n                }\n                if (jsonStr.startsWith('```')) {\n                    jsonStr = jsonStr.slice(3);\n                }\n                if (jsonStr.endsWith('```')) {\n                    jsonStr = jsonStr.slice(0, -3);\n                }\n                jsonStr = jsonStr.trim();\n                const parsed = JSON.parse(jsonStr);\n                if (!parsed.modifiedContent) {\n                    return {\n                        success: false,\n                        error: 'AI response missing modifiedContent field'\n                    };\n                }\n                return {\n                    success: true,\n                    modifiedContent: parsed.modifiedContent,\n                    summary: parsed.summary || 'Changes applied'\n                };\n            }\n            catch (parseError) {\n                (0, logger_1.logError)('AI IPC: Failed to parse edit response as JSON', parseError);\n                return {\n                    success: false,\n                    error: 'Failed to parse AI response as JSON. The AI may not have returned valid JSON.'\n                };\n            }\n        }\n        catch (error) {\n            (0, logger_1.logError)('AI IPC: edit-request failed', error);\n            return { success: false, error: error.message };\n        }\n    }));\n    // Get Provider Statuses\n    electron_1.ipcMain.handle('ai:get-provider-status', () => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('AI IPC: get-provider-status');\n        const result = {\n            xai: { enabled: false, status: 'unchecked' },\n            claude: { enabled: false, status: 'unchecked' },\n            openai: { enabled: false, status: 'unchecked' },\n        };\n        // Check xAI\n        if ((0, xaiApi_1.hasApiKey)()) {\n            result.xai.enabled = true;\n            try {\n                yield (0, xaiApi_1.listModels)();\n                result.xai.status = 'success';\n            }\n            catch (_a) {\n                result.xai.status = 'error';\n            }\n        }\n        // Check Claude\n        if ((0, claudeApi_1.hasApiKey)()) {\n            result.claude.enabled = true;\n            try {\n                yield (0, claudeApi_1.listClaudeModels)();\n                result.claude.status = 'success';\n            }\n            catch (_b) {\n                result.claude.status = 'error';\n            }\n        }\n        // Check OpenAI\n        if ((0, openaiApi_1.hasApiKey)()) {\n            result.openai.enabled = true;\n            try {\n                yield (0, openaiApi_1.listOpenAIModels)();\n                result.openai.status = 'success';\n            }\n            catch (_c) {\n                result.openai.status = 'error';\n            }\n        }\n        (0, logger_1.log)('AI IPC: provider status result', result);\n        return result;\n    }));\n    (0, logger_1.log)('AI IPC handlers registered');\n}\n// Format model ID to display name\nfunction formatModelName(modelId) {\n    // Handle common patterns\n    return modelId\n        .replace(/-/g, ' ')\n        .replace(/\\b\\w/g, c => c.toUpperCase())\n        .replace(/(\\d+)$/g, ' $1')\n        .trim();\n}\n\n\n//# sourceURL=webpack://markdownplus/./src/main/aiIpcHandlers.ts?");

/***/ }),

/***/ "./src/main/logger.ts":
/*!****************************!*\
  !*** ./src/main/logger.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.initLogger = initLogger;\nexports.log = log;\nexports.logError = logError;\nexports.flushLogsSync = flushLogsSync;\nexports.getLogFilePath = getLogFilePath;\nconst fs = __importStar(__webpack_require__(/*! fs/promises */ \"fs/promises\"));\nconst path = __importStar(__webpack_require__(/*! path */ \"path\"));\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nlet logFilePath;\nlet logBuffer = [];\nlet isWriting = false;\n// Initialize logger\nfunction initLogger() {\n    const appPath = electron_1.app.isPackaged\n        ? path.dirname(electron_1.app.getPath('exe'))\n        : electron_1.app.getAppPath();\n    logFilePath = path.join(appPath, 'markdownplus-debug.log');\n    // Clear old log file on startup\n    try {\n        fs.writeFile(logFilePath, `=== MarkdownPlus Debug Log ===\\n`, 'utf-8').catch(() => { });\n    }\n    catch (_a) {\n        // Ignore errors\n    }\n    log('Logger initialized', { appPath, logFilePath, isPackaged: electron_1.app.isPackaged });\n}\n// Write buffered logs to file\nfunction flushLogs() {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (isWriting || logBuffer.length === 0)\n            return;\n        isWriting = true;\n        const toWrite = [...logBuffer];\n        logBuffer = [];\n        try {\n            yield fs.appendFile(logFilePath, toWrite.join(''), 'utf-8');\n        }\n        catch (error) {\n            console.error('Failed to write logs:', error);\n        }\n        finally {\n            isWriting = false;\n        }\n    });\n}\n// Log a message with optional data\nfunction log(message, data) {\n    const timestamp = new Date().toISOString();\n    const logLine = data\n        ? `[${timestamp}] ${message}\\n${JSON.stringify(data, null, 2)}\\n\\n`\n        : `[${timestamp}] ${message}\\n\\n`;\n    // Console output\n    console.log(`[LOG] ${message}`, data || '');\n    // Buffer for file write\n    logBuffer.push(logLine);\n    // Flush after a short delay\n    setTimeout(flushLogs, 100);\n}\n// Log an error\nfunction logError(message, error) {\n    const timestamp = new Date().toISOString();\n    const errorInfo = Object.assign({ message: (error === null || error === void 0 ? void 0 : error.message) || String(error), stack: error === null || error === void 0 ? void 0 : error.stack }, error);\n    const logLine = `[${timestamp}] ERROR: ${message}\\n${JSON.stringify(errorInfo, null, 2)}\\n\\n`;\n    console.error(`[ERROR] ${message}`, error);\n    logBuffer.push(logLine);\n    setTimeout(flushLogs, 100);\n}\n// Force flush logs (call before app quit)\nfunction flushLogsSync() {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield flushLogs();\n    });\n}\n// Get log file path\nfunction getLogFilePath() {\n    return logFilePath;\n}\n\n\n//# sourceURL=webpack://markdownplus/./src/main/logger.ts?");

/***/ }),

/***/ "./src/main/main.ts":
/*!**************************!*\
  !*** ./src/main/main.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst path = __importStar(__webpack_require__(/*! path */ \"path\"));\nconst fs = __importStar(__webpack_require__(/*! fs/promises */ \"fs/promises\"));\nconst fsSync = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst dotenv = __importStar(__webpack_require__(/*! dotenv */ \"./node_modules/dotenv/lib/main.js\"));\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/main/logger.ts\");\nconst aiIpcHandlers_1 = __webpack_require__(/*! ./aiIpcHandlers */ \"./src/main/aiIpcHandlers.ts\");\nconst secureStorageIpcHandlers_1 = __webpack_require__(/*! ./secureStorageIpcHandlers */ \"./src/main/secureStorageIpcHandlers.ts\");\nconst secureStorage_1 = __webpack_require__(/*! ./services/secureStorage */ \"./src/main/services/secureStorage.ts\");\nconst xaiApi_1 = __webpack_require__(/*! ./services/xaiApi */ \"./src/main/services/xaiApi.ts\");\nconst claudeApi_1 = __webpack_require__(/*! ./services/claudeApi */ \"./src/main/services/claudeApi.ts\");\nconst openaiApi_1 = __webpack_require__(/*! ./services/openaiApi */ \"./src/main/services/openaiApi.ts\");\n// Load .env file for development (optional - will be ignored if not present)\n// In production builds, this file typically won't exist, and secure storage will be used\ndotenv.config();\nlet mainWindow;\nlet pendingFilesToOpen = [];\nlet fileWatchers = new Map();\n// Supported markdown file extensions (for Windows file associations)\nconst MARKDOWN_EXTENSIONS = ['.md', '.markdown', '.mdown', '.mkd', '.mkdn', '.mdx', '.mdwn'];\n// Check if a file path is a markdown file\nfunction isMarkdownFile(filePath) {\n    const lowerPath = filePath.toLowerCase();\n    return MARKDOWN_EXTENSIONS.some(ext => lowerPath.endsWith(ext));\n}\n// Config file path - in user data directory (preserved during uninstall)\nconst getConfigPath = () => {\n    // Use userData directory which is preserved across installations\n    // Windows: C:\\Users\\<user>\\AppData\\Roaming\\markdownplus\n    // macOS: ~/Library/Application Support/markdownplus\n    // Linux: ~/.config/markdownplus\n    const userDataPath = electron_1.app.getPath('userData');\n    return path.join(userDataPath, 'config.json');\n};\n// Supported image extensions\nconst IMAGE_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp'];\n// Default config\nconst defaultConfig = {\n    recentFiles: [],\n    openFiles: [],\n    defaultLineEnding: 'CRLF',\n    devToolsOpen: false,\n    aiModels: {},\n    imageSaveFolder: 'images',\n};\n// Detect line ending in content\nfunction detectLineEnding(content) {\n    if (content.includes('\\r\\n')) {\n        return 'CRLF';\n    }\n    return 'LF';\n}\n// Normalize line endings for saving\nfunction normalizeLineEndings(content, lineEnding) {\n    // First normalize to LF\n    const normalized = content.replace(/\\r\\n/g, '\\n');\n    // Then convert to target\n    if (lineEnding === 'CRLF') {\n        return normalized.replace(/\\n/g, '\\r\\n');\n    }\n    return normalized;\n}\n// Load config from file\nfunction loadConfig() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const configPath = getConfigPath();\n            const data = yield fs.readFile(configPath, 'utf-8');\n            const loadedConfig = JSON.parse(data);\n            // Handle migration from old format (string arrays) to new format (object arrays)\n            // If recentFiles or openFiles contain strings instead of objects, reset them\n            if (loadedConfig.recentFiles && Array.isArray(loadedConfig.recentFiles) && loadedConfig.recentFiles.length > 0) {\n                if (typeof loadedConfig.recentFiles[0] === 'string') {\n                    loadedConfig.recentFiles = [];\n                }\n            }\n            if (loadedConfig.openFiles && Array.isArray(loadedConfig.openFiles) && loadedConfig.openFiles.length > 0) {\n                if (typeof loadedConfig.openFiles[0] === 'string') {\n                    loadedConfig.openFiles = [];\n                }\n            }\n            return Object.assign(Object.assign({}, defaultConfig), loadedConfig);\n        }\n        catch (_a) {\n            return defaultConfig;\n        }\n    });\n}\n// Save config to file\nfunction saveConfig(config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const configPath = getConfigPath();\n            yield fs.writeFile(configPath, JSON.stringify(config, null, 2), 'utf-8');\n        }\n        catch (error) {\n            console.error('Failed to save config:', error);\n        }\n    });\n}\n// Open config file for editing - creates if doesn't exist\nfunction openConfigFile() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const configPath = getConfigPath();\n        try {\n            // Check if file exists, if not create it with defaults\n            try {\n                yield fs.access(configPath);\n            }\n            catch (_a) {\n                // File doesn't exist, create it\n                yield fs.writeFile(configPath, JSON.stringify(defaultConfig, null, 2), 'utf-8');\n            }\n            const content = yield fs.readFile(configPath, 'utf-8');\n            const lineEnding = detectLineEnding(content);\n            return { filePath: configPath, content, lineEnding };\n        }\n        catch (error) {\n            console.error('Failed to open config file:', error);\n            return null;\n        }\n    });\n}\n// Sync AI models with config - adds new models, preserves existing enabled/disabled state\nfunction syncAIModelsConfig() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const config = yield loadConfig();\n            // Initialize aiModels if it doesn't exist\n            if (!config.aiModels) {\n                config.aiModels = {};\n            }\n            let configUpdated = false;\n            // Sync xAI models\n            if ((0, xaiApi_1.hasApiKey)()) {\n                try {\n                    const models = yield (0, xaiApi_1.listModels)();\n                    if (!config.aiModels.xai) {\n                        config.aiModels.xai = {};\n                        configUpdated = true;\n                    }\n                    for (const model of models) {\n                        if (!config.aiModels.xai[model.id]) {\n                            config.aiModels.xai[model.id] = { enabled: true };\n                            configUpdated = true;\n                            (0, logger_1.log)('Added new xAI model to config', { modelId: model.id });\n                        }\n                    }\n                }\n                catch (error) {\n                    (0, logger_1.logError)('Failed to sync xAI models', error);\n                }\n            }\n            // Sync Claude models\n            if ((0, claudeApi_1.hasApiKey)()) {\n                try {\n                    const models = yield (0, claudeApi_1.listClaudeModels)();\n                    if (!config.aiModels.claude) {\n                        config.aiModels.claude = {};\n                        configUpdated = true;\n                    }\n                    for (const model of models) {\n                        if (!config.aiModels.claude[model.id]) {\n                            config.aiModels.claude[model.id] = { enabled: true };\n                            configUpdated = true;\n                            (0, logger_1.log)('Added new Claude model to config', { modelId: model.id });\n                        }\n                    }\n                }\n                catch (error) {\n                    (0, logger_1.logError)('Failed to sync Claude models', error);\n                }\n            }\n            // Sync OpenAI models\n            if ((0, openaiApi_1.hasApiKey)()) {\n                try {\n                    const models = yield (0, openaiApi_1.listOpenAIModels)();\n                    if (!config.aiModels.openai) {\n                        config.aiModels.openai = {};\n                        configUpdated = true;\n                    }\n                    for (const model of models) {\n                        if (!config.aiModels.openai[model.id]) {\n                            config.aiModels.openai[model.id] = { enabled: true };\n                            configUpdated = true;\n                            (0, logger_1.log)('Added new OpenAI model to config', { modelId: model.id });\n                        }\n                    }\n                }\n                catch (error) {\n                    (0, logger_1.logError)('Failed to sync OpenAI models', error);\n                }\n            }\n            // Save config if it was updated\n            if (configUpdated) {\n                yield saveConfig(config);\n                (0, logger_1.log)('AI models config synced and saved');\n            }\n        }\n        catch (error) {\n            (0, logger_1.logError)('Failed to sync AI models config', error);\n        }\n    });\n}\n// Watch a file for external changes\nfunction watchFile(filePath) {\n    // Don't watch if already watching\n    if (fileWatchers.has(filePath)) {\n        return;\n    }\n    try {\n        const watcher = fsSync.watch(filePath, (eventType) => {\n            if (eventType === 'change') {\n                (0, logger_1.log)('File changed externally', { filePath });\n                // Notify renderer\n                if (mainWindow && !mainWindow.isDestroyed()) {\n                    mainWindow.webContents.send('file:external-change', filePath);\n                }\n            }\n        });\n        fileWatchers.set(filePath, watcher);\n        (0, logger_1.log)('Started watching file', { filePath });\n    }\n    catch (error) {\n        (0, logger_1.logError)(`Failed to watch file: ${filePath}`, error);\n    }\n}\n// Stop watching a file\nfunction unwatchFile(filePath) {\n    const watcher = fileWatchers.get(filePath);\n    if (watcher) {\n        watcher.close();\n        fileWatchers.delete(filePath);\n        (0, logger_1.log)('Stopped watching file', { filePath });\n    }\n}\n// Register IPC handlers\nfunction registerIpcHandlers() {\n    // File: Open dialog\n    electron_1.ipcMain.handle('file:open', () => __awaiter(this, void 0, void 0, function* () {\n        const result = yield electron_1.dialog.showOpenDialog(mainWindow, {\n            filters: [\n                { name: 'Markup Files', extensions: ['md', 'markdown', 'mdown', 'mkd', 'mkdn', 'mdx', 'mdwn', 'rst', 'rest'] },\n                { name: 'Text Files', extensions: ['txt'] },\n                { name: 'Other Markup', extensions: ['adoc', 'asciidoc', 'org', 'textile'] },\n                { name: 'All Files', extensions: ['*'] },\n            ],\n            properties: ['openFile', 'multiSelections'],\n        });\n        if (result.canceled || result.filePaths.length === 0) {\n            return null;\n        }\n        // Read all selected files\n        const files = [];\n        for (const filePath of result.filePaths) {\n            try {\n                const content = yield fs.readFile(filePath, 'utf-8');\n                const lineEnding = detectLineEnding(content);\n                files.push({ filePath, content, lineEnding });\n            }\n            catch (error) {\n                console.error(`Failed to read file ${filePath}:`, error);\n            }\n        }\n        return files.length > 0 ? files : null;\n    }));\n    // File: Read specific file\n    electron_1.ipcMain.handle('file:read', (_event, filePath) => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('IPC: file:read called', { filePath });\n        try {\n            const content = yield fs.readFile(filePath, 'utf-8');\n            const lineEnding = detectLineEnding(content);\n            (0, logger_1.log)('IPC: file:read success', { filePath, contentLength: content.length, lineEnding });\n            return { filePath, content, lineEnding };\n        }\n        catch (error) {\n            (0, logger_1.logError)('IPC: file:read failed', error);\n            return null;\n        }\n    }));\n    // File: Read for attachment (supports images and text files)\n    electron_1.ipcMain.handle('file:read-for-attachment', (_event, filePath) => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('IPC: file:read-for-attachment called', { filePath });\n        try {\n            const ext = path.extname(filePath).toLowerCase();\n            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'];\n            const textExtensions = ['.txt', '.md', '.markdown', '.json', '.js', '.ts', '.tsx', '.jsx', '.css', '.html', '.xml', '.yaml', '.yml', '.log'];\n            if (imageExtensions.includes(ext)) {\n                // Read as binary and base64 encode\n                const buffer = yield fs.readFile(filePath);\n                const base64 = buffer.toString('base64');\n                const mimeType = ext === '.png' ? 'image/png'\n                    : ext === '.jpg' || ext === '.jpeg' ? 'image/jpeg'\n                        : ext === '.gif' ? 'image/gif'\n                            : ext === '.webp' ? 'image/webp'\n                                : 'image/bmp';\n                (0, logger_1.log)('IPC: file:read-for-attachment success (image)', { filePath, size: buffer.length });\n                return {\n                    type: 'image',\n                    mimeType,\n                    data: base64,\n                    size: buffer.length,\n                };\n            }\n            else if (textExtensions.includes(ext) || !ext) {\n                // Read as text\n                const content = yield fs.readFile(filePath, 'utf-8');\n                (0, logger_1.log)('IPC: file:read-for-attachment success (text)', { filePath, size: content.length });\n                return {\n                    type: 'text',\n                    data: content,\n                    size: content.length,\n                };\n            }\n            else {\n                // Unsupported file type\n                return {\n                    type: 'unsupported',\n                    error: `File type ${ext} is not supported`,\n                };\n            }\n        }\n        catch (error) {\n            (0, logger_1.logError)('IPC: file:read-for-attachment failed', error);\n            return {\n                type: 'error',\n                error: error instanceof Error ? error.message : 'Failed to read file',\n            };\n        }\n    }));\n    // File: Save to existing path\n    electron_1.ipcMain.handle('file:save', (_event, filePath, content) => __awaiter(this, void 0, void 0, function* () {\n        try {\n            // Detect original line ending and preserve it\n            let lineEnding = 'LF';\n            try {\n                const originalContent = yield fs.readFile(filePath, 'utf-8');\n                lineEnding = detectLineEnding(originalContent);\n            }\n            catch (_a) {\n                // File might not exist yet, use default\n                lineEnding = process.platform === 'win32' ? 'CRLF' : 'LF';\n            }\n            const normalizedContent = normalizeLineEndings(content, lineEnding);\n            yield fs.writeFile(filePath, normalizedContent, 'utf-8');\n            return { success: true, filePath };\n        }\n        catch (error) {\n            console.error('Failed to save file:', error);\n            return { success: false, filePath, error: String(error) };\n        }\n    }));\n    // File: Save As dialog\n    electron_1.ipcMain.handle('file:save-as', (_event, content, defaultName) => __awaiter(this, void 0, void 0, function* () {\n        const result = yield electron_1.dialog.showSaveDialog(mainWindow, {\n            defaultPath: defaultName || 'Untitled.md',\n            filters: [\n                { name: 'Markdown', extensions: ['md'] },\n                { name: 'Text Files', extensions: ['txt'] },\n                { name: 'All Files', extensions: ['*'] },\n            ],\n        });\n        if (result.canceled || !result.filePath) {\n            return null;\n        }\n        try {\n            const lineEnding = process.platform === 'win32' ? 'CRLF' : 'LF';\n            const normalizedContent = normalizeLineEndings(content, lineEnding);\n            yield fs.writeFile(result.filePath, normalizedContent, 'utf-8');\n            return { success: true, filePath: result.filePath };\n        }\n        catch (error) {\n            console.error('Failed to save file:', error);\n            return { success: false, filePath: result.filePath, error: String(error) };\n        }\n    }));\n    // File: Rename\n    electron_1.ipcMain.handle('file:rename', (_event, oldPath, newPath) => __awaiter(this, void 0, void 0, function* () {\n        try {\n            yield fs.rename(oldPath, newPath);\n            return { success: true };\n        }\n        catch (error) {\n            console.error('Failed to rename file:', error);\n            throw error;\n        }\n    }));\n    // Config: Load\n    electron_1.ipcMain.handle('config:load', () => __awaiter(this, void 0, void 0, function* () {\n        return yield loadConfig();\n    }));\n    // Config: Save\n    electron_1.ipcMain.handle('config:save', (_event, config) => __awaiter(this, void 0, void 0, function* () {\n        yield saveConfig(config);\n    }));\n    // Config: Open for editing\n    electron_1.ipcMain.handle('config:open', () => __awaiter(this, void 0, void 0, function* () {\n        return yield openConfigFile();\n    }));\n    // Get initial files to open (from command line)\n    electron_1.ipcMain.handle('get-initial-files', () => {\n        (0, logger_1.log)('IPC: get-initial-files called', { pendingFiles: pendingFilesToOpen });\n        const files = pendingFilesToOpen;\n        pendingFilesToOpen = []; // Clear after retrieving\n        (0, logger_1.log)('IPC: Returning files and clearing pending', { files });\n        return files;\n    });\n    // Renderer ready - send pending files\n    electron_1.ipcMain.handle('renderer-ready', () => {\n        (0, logger_1.log)('IPC: renderer-ready called', { pendingFiles: pendingFilesToOpen });\n        if (pendingFilesToOpen.length > 0 && mainWindow && !mainWindow.isDestroyed()) {\n            (0, logger_1.log)('Sending files to renderer after ready signal', { files: pendingFilesToOpen });\n            mainWindow.webContents.send('open-files-from-args', pendingFilesToOpen);\n            (0, logger_1.log)('IPC event \"open-files-from-args\" sent to renderer');\n            const files = [...pendingFilesToOpen];\n            pendingFilesToOpen = []; // Clear after sending\n            (0, logger_1.log)('Returning files from renderer-ready', { files });\n            return files;\n        }\n        (0, logger_1.log)('No files to send from renderer-ready');\n        return [];\n    });\n    // Config: Sync recent files with open files\n    electron_1.ipcMain.handle('config:sync-recent-files', (_event, openFiles) => __awaiter(this, void 0, void 0, function* () {\n        const config = yield loadConfig();\n        const newConfig = Object.assign(Object.assign({}, config), { recentFiles: openFiles, openFiles: openFiles });\n        yield saveConfig(newConfig);\n    }));\n    // Dialog: Confirm close\n    electron_1.ipcMain.handle('dialog:confirm-close', (_event, fileName) => __awaiter(this, void 0, void 0, function* () {\n        const result = yield electron_1.dialog.showMessageBox(mainWindow, {\n            type: 'question',\n            buttons: ['Save', \"Don't Save\", 'Cancel'],\n            defaultId: 0,\n            cancelId: 2,\n            title: 'Unsaved Changes',\n            message: `Do you want to save changes to \"${fileName}\"?`,\n            detail: 'Your changes will be lost if you don\\'t save them.',\n        });\n        const actions = ['save', 'discard', 'cancel'];\n        return { action: actions[result.response] };\n    }));\n    // DevTools: Toggle\n    electron_1.ipcMain.handle('devtools:toggle', () => __awaiter(this, void 0, void 0, function* () {\n        if (mainWindow && !mainWindow.isDestroyed()) {\n            if (mainWindow.webContents.isDevToolsOpened()) {\n                mainWindow.webContents.closeDevTools();\n                // Config will be saved by devtools-closed event listener\n                return false;\n            }\n            else {\n                mainWindow.webContents.openDevTools();\n                // Config will be saved by devtools-opened event listener\n                return true;\n            }\n        }\n        return false;\n    }));\n    // DevTools: Get state\n    electron_1.ipcMain.handle('devtools:get-state', () => __awaiter(this, void 0, void 0, function* () {\n        if (mainWindow && !mainWindow.isDestroyed()) {\n            return mainWindow.webContents.isDevToolsOpened();\n        }\n        return false;\n    }));\n    // Log: Get path\n    electron_1.ipcMain.handle('log:get-path', () => {\n        return (0, logger_1.getLogFilePath)();\n    });\n    // Console: Log message (from renderer)\n    electron_1.ipcMain.on('console:log', (_event, level, ...args) => {\n        const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' ');\n        (0, logger_1.log)(`[RENDERER ${level.toUpperCase()}] ${message}`);\n    });\n    // Dialog: External change\n    electron_1.ipcMain.handle('dialog:external-change', (_event, fileName) => __awaiter(this, void 0, void 0, function* () {\n        const result = yield electron_1.dialog.showMessageBox(mainWindow, {\n            type: 'question',\n            buttons: ['Reload', 'Keep Current'],\n            defaultId: 0,\n            title: 'File Changed',\n            message: `\"${fileName}\" has been modified externally.`,\n            detail: 'Do you want to reload the file or keep your current version?',\n        });\n        return result.response === 0 ? 'reload' : 'keep';\n    }));\n    // Dialog: Open file\n    electron_1.ipcMain.handle('dialog:open-file', (_event, options) => __awaiter(this, void 0, void 0, function* () {\n        const result = yield electron_1.dialog.showOpenDialog(mainWindow, {\n            properties: options.properties,\n        });\n        return result;\n    }));\n    // Window: Set title\n    electron_1.ipcMain.handle('window:set-title', (_event, title) => __awaiter(this, void 0, void 0, function* () {\n        mainWindow === null || mainWindow === void 0 ? void 0 : mainWindow.setTitle(title);\n    }));\n    // Window: Get bounds\n    electron_1.ipcMain.handle('window:get-bounds', () => __awaiter(this, void 0, void 0, function* () {\n        return mainWindow === null || mainWindow === void 0 ? void 0 : mainWindow.getBounds();\n    }));\n    // Window: Minimize\n    electron_1.ipcMain.handle('window:minimize', () => __awaiter(this, void 0, void 0, function* () {\n        mainWindow === null || mainWindow === void 0 ? void 0 : mainWindow.minimize();\n    }));\n    // Window: Maximize/Unmaximize\n    electron_1.ipcMain.handle('window:maximize', () => __awaiter(this, void 0, void 0, function* () {\n        if (mainWindow === null || mainWindow === void 0 ? void 0 : mainWindow.isMaximized()) {\n            mainWindow.unmaximize();\n        }\n        else {\n            mainWindow === null || mainWindow === void 0 ? void 0 : mainWindow.maximize();\n        }\n    }));\n    // Window: Close\n    electron_1.ipcMain.handle('window:close', () => __awaiter(this, void 0, void 0, function* () {\n        mainWindow === null || mainWindow === void 0 ? void 0 : mainWindow.close();\n    }));\n    // Shell: Show in folder\n    electron_1.ipcMain.handle('shell:show-in-folder', (_event, filePath) => __awaiter(this, void 0, void 0, function* () {\n        electron_1.shell.showItemInFolder(filePath);\n    }));\n    // Shell: Open external URL\n    electron_1.ipcMain.handle('shell:open-external', (_event, url) => __awaiter(this, void 0, void 0, function* () {\n        yield electron_1.shell.openExternal(url);\n    }));\n    // File watching\n    electron_1.ipcMain.handle('file:watch', (_event, filePath) => __awaiter(this, void 0, void 0, function* () {\n        watchFile(filePath);\n    }));\n    electron_1.ipcMain.handle('file:unwatch', (_event, filePath) => __awaiter(this, void 0, void 0, function* () {\n        unwatchFile(filePath);\n    }));\n    // File: Save clipboard image to disk\n    electron_1.ipcMain.handle('file:save-image', (_event, base64Data, documentDir) => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('IPC: file:save-image called', { documentDir });\n        try {\n            // Load config to get image save folder name\n            const config = yield loadConfig();\n            const folderName = config.imageSaveFolder || 'images';\n            const imageDir = path.join(documentDir, folderName);\n            // Create images folder if it doesn't exist\n            yield fs.mkdir(imageDir, { recursive: true });\n            // Generate unique filename with timestamp\n            const now = new Date();\n            const timestamp = now.getFullYear().toString() +\n                String(now.getMonth() + 1).padStart(2, '0') +\n                String(now.getDate()).padStart(2, '0') + '-' +\n                String(now.getHours()).padStart(2, '0') +\n                String(now.getMinutes()).padStart(2, '0') +\n                String(now.getSeconds()).padStart(2, '0') + '-' +\n                String(now.getMilliseconds()).padStart(3, '0');\n            let fileName = `image-${timestamp}.png`;\n            let filePath = path.join(imageDir, fileName);\n            // Handle unlikely collision by appending random suffix\n            try {\n                yield fs.access(filePath);\n                // File exists, add random suffix\n                const suffix = Math.random().toString(36).substring(2, 6);\n                fileName = `image-${timestamp}-${suffix}.png`;\n                filePath = path.join(imageDir, fileName);\n            }\n            catch (_a) {\n                // File doesn't exist, good to go\n            }\n            // Decode base64 and write to disk\n            const buffer = Buffer.from(base64Data, 'base64');\n            yield fs.writeFile(filePath, buffer);\n            // Build relative path with forward slashes\n            const relativePath = `./${folderName}/${fileName}`.replace(/\\\\/g, '/');\n            (0, logger_1.log)('IPC: file:save-image success', { filePath, relativePath, size: buffer.length });\n            return { success: true, relativePath };\n        }\n        catch (error) {\n            (0, logger_1.logError)('IPC: file:save-image failed', error);\n            return { success: false, error: error instanceof Error ? error.message : 'Failed to save image' };\n        }\n    }));\n    // File: Save dropped image (copy existing file to images folder)\n    electron_1.ipcMain.handle('file:save-dropped-image', (_event, sourcePath, documentDir) => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('IPC: file:save-dropped-image called', { sourcePath, documentDir });\n        try {\n            const ext = path.extname(sourcePath).toLowerCase();\n            if (!IMAGE_EXTENSIONS.includes(ext)) {\n                return { success: false, error: `Unsupported image format: ${ext}` };\n            }\n            // Load config to get image save folder name\n            const config = yield loadConfig();\n            const folderName = config.imageSaveFolder || 'images';\n            const imageDir = path.join(documentDir, folderName);\n            // Create images folder if it doesn't exist\n            yield fs.mkdir(imageDir, { recursive: true });\n            // Generate unique filename preserving original extension\n            const now = new Date();\n            const timestamp = now.getFullYear().toString() +\n                String(now.getMonth() + 1).padStart(2, '0') +\n                String(now.getDate()).padStart(2, '0') + '-' +\n                String(now.getHours()).padStart(2, '0') +\n                String(now.getMinutes()).padStart(2, '0') +\n                String(now.getSeconds()).padStart(2, '0') + '-' +\n                String(now.getMilliseconds()).padStart(3, '0');\n            let fileName = `image-${timestamp}${ext}`;\n            let filePath = path.join(imageDir, fileName);\n            // Handle unlikely collision\n            try {\n                yield fs.access(filePath);\n                const suffix = Math.random().toString(36).substring(2, 6);\n                fileName = `image-${timestamp}-${suffix}${ext}`;\n                filePath = path.join(imageDir, fileName);\n            }\n            catch (_a) {\n                // File doesn't exist, good to go\n            }\n            // Copy the source image to the images folder\n            yield fs.copyFile(sourcePath, filePath);\n            // Build relative path with forward slashes\n            const relativePath = `./${folderName}/${fileName}`.replace(/\\\\/g, '/');\n            (0, logger_1.log)('IPC: file:save-dropped-image success', { filePath, relativePath });\n            return { success: true, relativePath };\n        }\n        catch (error) {\n            (0, logger_1.logError)('IPC: file:save-dropped-image failed', error);\n            return { success: false, error: error instanceof Error ? error.message : 'Failed to save image' };\n        }\n    }));\n}\nfunction createWindow() {\n    // Create the browser window with secure settings\n    mainWindow = new electron_1.BrowserWindow({\n        width: 1200,\n        height: 800,\n        minWidth: 600,\n        minHeight: 400,\n        frame: false,\n        icon: path.join(__dirname, 'assets', process.platform === 'win32' ? 'icon.ico' : 'MarkdownPlus.png'),\n        webPreferences: {\n            nodeIntegration: false,\n            contextIsolation: true,\n            preload: path.join(__dirname, 'preload.js'),\n        },\n    });\n    // Load the index.html file\n    mainWindow.loadFile(path.join(__dirname, 'index.html'));\n    // Open the DevTools in development mode or if saved in config\n    if (true) {\n        (0, logger_1.log)('Opening DevTools', { isDev: true });\n        mainWindow.webContents.openDevTools();\n    }\n    else {}\n    // Listen for DevTools open/close events (for native UI interactions)\n    mainWindow.webContents.on('devtools-opened', () => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('DevTools opened via native UI');\n        const config = yield loadConfig();\n        yield saveConfig(Object.assign(Object.assign({}, config), { devToolsOpen: true }));\n    }));\n    mainWindow.webContents.on('devtools-closed', () => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('DevTools closed via native UI');\n        const config = yield loadConfig();\n        yield saveConfig(Object.assign(Object.assign({}, config), { devToolsOpen: false }));\n    }));\n    // Emitted when the window is closed\n    mainWindow.on('closed', () => {\n        // Dereference the window object\n        mainWindow = null;\n    });\n}\n// This method will be called when Electron has finished initialization\nelectron_1.app.whenReady().then(() => __awaiter(void 0, void 0, void 0, function* () {\n    // Initialize logger first\n    (0, logger_1.initLogger)();\n    (0, logger_1.log)('=== App Starting ===');\n    (0, logger_1.log)('Electron app ready');\n    (0, logger_1.log)('Config file location', { path: getConfigPath() });\n    // Load encrypted API keys from disk\n    (0, secureStorage_1.loadEncryptedKeys)();\n    // Handle command line arguments (file associations) - MUST be done before creating window\n    const args = process.argv.slice(1); // Skip the first argument (electron executable)\n    (0, logger_1.log)('Command line arguments received', { args, length: args.length });\n    // Filter for markdown files (case-insensitive) and exclude flags\n    pendingFilesToOpen = args.filter(arg => {\n        const isMarkdown = isMarkdownFile(arg);\n        const isNotFlag = !arg.startsWith('--') && !arg.startsWith('-');\n        const result = isMarkdown && isNotFlag;\n        (0, logger_1.log)('Filtering argument', { arg, isMarkdown, isNotFlag, included: result });\n        return result;\n    });\n    (0, logger_1.log)('Pending files to open after filtering', { pendingFilesToOpen, count: pendingFilesToOpen.length });\n    (0, logger_1.log)('Registering IPC handlers');\n    registerIpcHandlers();\n    (0, aiIpcHandlers_1.registerAIIpcHandlers)();\n    (0, secureStorageIpcHandlers_1.registerSecureStorageIpcHandlers)();\n    // Sync AI models with config\n    (0, logger_1.log)('Syncing AI models config');\n    yield syncAIModelsConfig();\n    // Remove the native menu bar\n    electron_1.Menu.setApplicationMenu(null);\n    (0, logger_1.log)('Creating main window');\n    createWindow();\n    (0, logger_1.log)('Main window created');\n}));\n// Handle second instance (when user tries to open another file while app is running)\nelectron_1.app.on('second-instance', (_event, commandLine) => {\n    (0, logger_1.log)('Second instance detected', { commandLine });\n    // Focus the existing window\n    if (mainWindow) {\n        if (mainWindow.isMinimized())\n            mainWindow.restore();\n        mainWindow.focus();\n    }\n    // Handle command line arguments from second instance\n    const args = commandLine.slice(1); // Skip the first argument\n    (0, logger_1.log)('Second instance args', { args });\n    const filesToOpen = args.filter(arg => {\n        const isMarkdown = isMarkdownFile(arg);\n        const isNotFlag = !arg.startsWith('--') && !arg.startsWith('-');\n        return isMarkdown && isNotFlag;\n    });\n    (0, logger_1.log)('Second instance files to open', { filesToOpen });\n    if (filesToOpen.length > 0 && mainWindow && !mainWindow.isDestroyed()) {\n        (0, logger_1.log)('Sending second instance files to renderer', { filesToOpen });\n        mainWindow.webContents.send('open-files-from-args', filesToOpen);\n    }\n});\n// Prevent multiple instances\nconst gotTheLock = electron_1.app.requestSingleInstanceLock();\nif (!gotTheLock) {\n    electron_1.app.quit();\n}\n// Flush logs before quit\nelectron_1.app.on('before-quit', () => __awaiter(void 0, void 0, void 0, function* () {\n    (0, logger_1.log)('App quitting, flushing logs');\n    yield (0, logger_1.flushLogsSync)();\n}));\n\n\n//# sourceURL=webpack://markdownplus/./src/main/main.ts?");

/***/ }),

/***/ "./src/main/secureStorageIpcHandlers.ts":
/*!**********************************************!*\
  !*** ./src/main/secureStorageIpcHandlers.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.registerSecureStorageIpcHandlers = registerSecureStorageIpcHandlers;\nexports.getApiKeyForService = getApiKeyForService;\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/main/logger.ts\");\nconst secureStorage_1 = __webpack_require__(/*! ./services/secureStorage */ \"./src/main/services/secureStorage.ts\");\nconst xaiApi_1 = __webpack_require__(/*! ./services/xaiApi */ \"./src/main/services/xaiApi.ts\");\nconst claudeApi_1 = __webpack_require__(/*! ./services/claudeApi */ \"./src/main/services/claudeApi.ts\");\nconst openaiApi_1 = __webpack_require__(/*! ./services/openaiApi */ \"./src/main/services/openaiApi.ts\");\nfunction registerSecureStorageIpcHandlers() {\n    (0, logger_1.log)('Registering Secure Storage IPC handlers');\n    // Set API Key (with validation)\n    electron_1.ipcMain.handle('secure-storage:set-api-key', (_event, data) => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('Secure Storage IPC: set-api-key', { provider: data.provider });\n        try {\n            // Validate API key before storing\n            let validationResult;\n            switch (data.provider) {\n                case 'xai':\n                    validationResult = yield (0, xaiApi_1.validateApiKey)(data.key);\n                    break;\n                case 'claude':\n                    validationResult = yield (0, claudeApi_1.validateApiKey)(data.key);\n                    break;\n                case 'openai':\n                    validationResult = yield (0, openaiApi_1.validateApiKey)(data.key);\n                    break;\n                default:\n                    return {\n                        success: false,\n                        error: `Unknown provider: ${data.provider}`,\n                    };\n            }\n            // If validation failed, return error without storing\n            if (!validationResult.valid) {\n                (0, logger_1.log)('Secure Storage IPC: API key validation failed', { provider: data.provider, error: validationResult.error });\n                return {\n                    success: false,\n                    error: validationResult.error || 'API key validation failed',\n                };\n            }\n            // Validation succeeded, store the key\n            (0, secureStorage_1.setApiKey)(data.provider, data.key);\n            (0, logger_1.log)('Secure Storage IPC: API key validated and stored successfully', { provider: data.provider });\n            return { success: true };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to store API key',\n            };\n        }\n    }));\n    // Check if API key exists\n    electron_1.ipcMain.handle('secure-storage:has-api-key', (_event, provider) => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('Secure Storage IPC: has-api-key', { provider });\n        return (0, secureStorage_1.hasApiKey)(provider);\n    }));\n    // Delete API key\n    electron_1.ipcMain.handle('secure-storage:delete-api-key', (_event, provider) => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('Secure Storage IPC: delete-api-key', { provider });\n        try {\n            (0, secureStorage_1.deleteApiKey)(provider);\n            return { success: true };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to delete API key',\n            };\n        }\n    }));\n    // Get API key status for all providers\n    electron_1.ipcMain.handle('secure-storage:get-key-status', () => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('Secure Storage IPC: get-key-status');\n        return {\n            xai: (0, secureStorage_1.hasApiKey)('xai'),\n            claude: (0, secureStorage_1.hasApiKey)('claude'),\n            openai: (0, secureStorage_1.hasApiKey)('openai'),\n        };\n    }));\n    // Check if secure storage is available\n    electron_1.ipcMain.handle('secure-storage:is-available', () => __awaiter(this, void 0, void 0, function* () {\n        (0, logger_1.log)('Secure Storage IPC: is-available');\n        return (0, secureStorage_1.isSecureStorageAvailable)();\n    }));\n    // Get API key (only for internal use by API services)\n    // This handler should NOT be exposed to renderer - it's for main process only\n    // We'll use a different approach - export a function that API services can call\n}\n/**\n * Get API key for use by API services in main process\n * This is NOT exposed via IPC to keep keys secure\n */\nfunction getApiKeyForService(provider) {\n    return (0, secureStorage_1.getApiKey)(provider);\n}\n\n\n//# sourceURL=webpack://markdownplus/./src/main/secureStorageIpcHandlers.ts?");

/***/ }),

/***/ "./src/main/services/claudeApi.ts":
/*!****************************************!*\
  !*** ./src/main/services/claudeApi.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_CLAUDE_MODELS = void 0;\nexports.callClaudeApi = callClaudeApi;\nexports.callClaudeApiWithSystemPrompt = callClaudeApiWithSystemPrompt;\nexports.listClaudeModels = listClaudeModels;\nexports.hasApiKey = hasApiKey;\nexports.validateApiKey = validateApiKey;\nconst logger_1 = __webpack_require__(/*! ../logger */ \"./src/main/logger.ts\");\nconst secureStorageIpcHandlers_1 = __webpack_require__(/*! ../secureStorageIpcHandlers */ \"./src/main/secureStorageIpcHandlers.ts\");\n// Default models to use if API listing fails\nexports.DEFAULT_CLAUDE_MODELS = [\n    { id: 'claude-sonnet-4-5-20250514', displayName: 'Claude Sonnet 4.5' },\n    { id: 'claude-sonnet-4-20250514', displayName: 'Claude Sonnet 4' },\n    { id: 'claude-haiku-3-5-20241022', displayName: 'Claude Haiku 3.5' },\n];\nfunction callClaudeApi(messages_1) {\n    return __awaiter(this, arguments, void 0, function* (messages, model = 'claude-sonnet-4-5-20250514') {\n        var _a;\n        // Only use secure storage (no .env fallback)\n        const apiKey = (0, secureStorageIpcHandlers_1.getApiKeyForService)('claude');\n        if (!apiKey) {\n            throw new Error('ANTHROPIC_API_KEY not found. Please set it in Settings');\n        }\n        // Format messages for Claude API (support attachments)\n        const formattedMessages = messages.map(msg => {\n            // If message has attachments, use content array format\n            if (msg.attachments && msg.attachments.length > 0) {\n                const content = [{ type: 'text', text: msg.content }];\n                // Add attachments\n                for (const attachment of msg.attachments) {\n                    if (attachment.type === 'image') {\n                        content.push({\n                            type: 'image',\n                            source: {\n                                type: 'base64',\n                                media_type: attachment.mimeType,\n                                data: attachment.data,\n                            },\n                        });\n                    }\n                    else if (attachment.type === 'text') {\n                        // Include text files as additional text content\n                        content.push({\n                            type: 'text',\n                            text: `\\n\\n[File: ${attachment.name}]\\n${attachment.data}`,\n                        });\n                    }\n                }\n                return { role: msg.role, content };\n            }\n            // Simple text message\n            return { role: msg.role, content: msg.content };\n        });\n        const requestBody = {\n            messages: formattedMessages,\n            model,\n            max_tokens: 4096,\n        };\n        (0, logger_1.log)('Claude API Request', {\n            url: 'https://api.anthropic.com/v1/messages',\n            model,\n            messageCount: messages.length,\n        });\n        try {\n            const response = yield fetch('https://api.anthropic.com/v1/messages', {\n                method: 'POST',\n                headers: {\n                    'X-Api-Key': apiKey,\n                    'Content-Type': 'application/json',\n                    'anthropic-version': '2023-06-01',\n                },\n                body: JSON.stringify(requestBody),\n            });\n            (0, logger_1.log)('Claude API Response Status', { status: response.status, statusText: response.statusText });\n            const data = yield response.json();\n            if (!response.ok) {\n                throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);\n            }\n            return ((_a = data.content[0]) === null || _a === void 0 ? void 0 : _a.text) || 'No response from Claude';\n        }\n        catch (error) {\n            (0, logger_1.logError)('Error calling Claude API', error);\n            throw new Error(`Failed to call Claude API: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    });\n}\n/**\n * Call Claude API with a system prompt for edit mode\n * This is used for structured JSON output when editing files\n */\nfunction callClaudeApiWithSystemPrompt(messages_1, systemPrompt_1) {\n    return __awaiter(this, arguments, void 0, function* (messages, systemPrompt, model = 'claude-sonnet-4-5-20250514') {\n        var _a;\n        const apiKey = (0, secureStorageIpcHandlers_1.getApiKeyForService)('claude');\n        if (!apiKey) {\n            throw new Error('ANTHROPIC_API_KEY not found. Please set it in Settings');\n        }\n        // Format messages for Claude API\n        const formattedMessages = messages.map(msg => {\n            if (msg.attachments && msg.attachments.length > 0) {\n                const content = [{ type: 'text', text: msg.content }];\n                for (const attachment of msg.attachments) {\n                    if (attachment.type === 'image') {\n                        content.push({\n                            type: 'image',\n                            source: {\n                                type: 'base64',\n                                media_type: attachment.mimeType,\n                                data: attachment.data,\n                            },\n                        });\n                    }\n                    else if (attachment.type === 'text') {\n                        content.push({\n                            type: 'text',\n                            text: `\\n\\n[File: ${attachment.name}]\\n${attachment.data}`,\n                        });\n                    }\n                }\n                return { role: msg.role, content };\n            }\n            return { role: msg.role, content: msg.content };\n        });\n        const requestBody = {\n            messages: formattedMessages,\n            model,\n            max_tokens: 8192,\n            system: systemPrompt,\n        };\n        (0, logger_1.log)('Claude API Request (with system prompt)', {\n            url: 'https://api.anthropic.com/v1/messages',\n            model,\n            messageCount: messages.length,\n        });\n        try {\n            const response = yield fetch('https://api.anthropic.com/v1/messages', {\n                method: 'POST',\n                headers: {\n                    'X-Api-Key': apiKey,\n                    'Content-Type': 'application/json',\n                    'anthropic-version': '2023-06-01',\n                },\n                body: JSON.stringify(requestBody),\n            });\n            (0, logger_1.log)('Claude API Response Status', { status: response.status, statusText: response.statusText });\n            const data = yield response.json();\n            if (!response.ok) {\n                throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);\n            }\n            return ((_a = data.content[0]) === null || _a === void 0 ? void 0 : _a.text) || 'No response from Claude';\n        }\n        catch (error) {\n            (0, logger_1.logError)('Error calling Claude API with system prompt', error);\n            throw new Error(`Failed to call Claude API: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    });\n}\nfunction listClaudeModels() {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Only use secure storage (no .env fallback)\n        const apiKey = (0, secureStorageIpcHandlers_1.getApiKeyForService)('claude');\n        if (!apiKey) {\n            throw new Error('ANTHROPIC_API_KEY not found. Please set it in Settings');\n        }\n        (0, logger_1.log)('Claude List Models Request', { url: 'https://api.anthropic.com/v1/models' });\n        try {\n            const response = yield fetch('https://api.anthropic.com/v1/models', {\n                method: 'GET',\n                headers: {\n                    'X-Api-Key': apiKey,\n                    'anthropic-version': '2023-06-01',\n                },\n            });\n            (0, logger_1.log)('Claude List Models Response Status', { status: response.status, statusText: response.statusText });\n            const data = yield response.json();\n            if (!response.ok) {\n                throw new Error(`Failed to list models: ${response.status} ${response.statusText}`);\n            }\n            return data.data;\n        }\n        catch (error) {\n            (0, logger_1.logError)('Error listing Claude models', error);\n            throw new Error(`Failed to list Claude models: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    });\n}\nfunction hasApiKey() {\n    // Only check secure storage (no .env fallback)\n    return !!(0, secureStorageIpcHandlers_1.getApiKeyForService)('claude');\n}\n/**\n * Validate an API key by making a test request\n */\nfunction validateApiKey(apiKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            (0, logger_1.log)('Claude: Validating API key');\n            const response = yield fetch('https://api.anthropic.com/v1/models', {\n                method: 'GET',\n                headers: {\n                    'X-Api-Key': apiKey,\n                    'anthropic-version': '2023-06-01',\n                },\n            });\n            if (!response.ok) {\n                const errorText = yield response.text();\n                (0, logger_1.log)('Claude: API key validation failed', { status: response.status, error: errorText });\n                return {\n                    valid: false,\n                    error: response.status === 401 ? 'Invalid API key' : `API error: ${response.statusText}`\n                };\n            }\n            (0, logger_1.log)('Claude: API key validated successfully');\n            return { valid: true };\n        }\n        catch (error) {\n            (0, logger_1.logError)('Claude: API key validation error', error);\n            return {\n                valid: false,\n                error: `Validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n            };\n        }\n    });\n}\n\n\n//# sourceURL=webpack://markdownplus/./src/main/services/claudeApi.ts?");

/***/ }),

/***/ "./src/main/services/openaiApi.ts":
/*!****************************************!*\
  !*** ./src/main/services/openaiApi.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_OPENAI_MODELS = void 0;\nexports.callOpenAIApi = callOpenAIApi;\nexports.callOpenAIApiWithJsonMode = callOpenAIApiWithJsonMode;\nexports.listOpenAIModels = listOpenAIModels;\nexports.hasApiKey = hasApiKey;\nexports.validateApiKey = validateApiKey;\nconst logger_1 = __webpack_require__(/*! ../logger */ \"./src/main/logger.ts\");\nconst secureStorageIpcHandlers_1 = __webpack_require__(/*! ../secureStorageIpcHandlers */ \"./src/main/secureStorageIpcHandlers.ts\");\n// Default models to use if API listing fails (only -latest models)\nexports.DEFAULT_OPENAI_MODELS = [\n    { id: 'gpt-4o-latest', displayName: 'GPT-4 Omni Latest' },\n    { id: 'gpt-4o-mini-latest', displayName: 'GPT-4 Omni Mini Latest' },\n    { id: 'gpt-4-turbo-latest', displayName: 'GPT-4 Turbo Latest' },\n];\nfunction callOpenAIApi(messages_1) {\n    return __awaiter(this, arguments, void 0, function* (messages, model = 'gpt-4o-mini-latest') {\n        var _a, _b;\n        // Only use secure storage (no .env fallback)\n        const apiKey = (0, secureStorageIpcHandlers_1.getApiKeyForService)('openai');\n        if (!apiKey) {\n            throw new Error('OPENAI_API_KEY not found. Please set it in Settings');\n        }\n        // Format messages for OpenAI API (support attachments)\n        const formattedMessages = messages.map(msg => {\n            // If message has attachments, use content array format\n            if (msg.attachments && msg.attachments.length > 0) {\n                const content = [{ type: 'text', text: msg.content }];\n                // Add attachments\n                for (const attachment of msg.attachments) {\n                    if (attachment.type === 'image') {\n                        content.push({\n                            type: 'image_url',\n                            image_url: {\n                                url: `data:${attachment.mimeType};base64,${attachment.data}`,\n                            },\n                        });\n                    }\n                    else if (attachment.type === 'text') {\n                        // Include text files as additional text content\n                        content.push({\n                            type: 'text',\n                            text: `\\n\\n[File: ${attachment.name}]\\n${attachment.data}`,\n                        });\n                    }\n                }\n                return { role: msg.role, content };\n            }\n            // Simple text message\n            return { role: msg.role, content: msg.content };\n        });\n        (0, logger_1.log)('OpenAI API Request', {\n            url: 'https://api.openai.com/v1/chat/completions',\n            model,\n            messageCount: messages.length,\n        });\n        try {\n            const response = yield fetch('https://api.openai.com/v1/chat/completions', {\n                method: 'POST',\n                headers: {\n                    'Authorization': `Bearer ${apiKey}`,\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    messages: formattedMessages,\n                    model,\n                }),\n            });\n            (0, logger_1.log)('OpenAI API Response Status', { status: response.status, statusText: response.statusText });\n            const data = yield response.json();\n            if (!response.ok) {\n                throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);\n            }\n            return ((_b = (_a = data.choices[0]) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.content) || 'No response from OpenAI';\n        }\n        catch (error) {\n            (0, logger_1.logError)('Error calling OpenAI API', error);\n            throw new Error(`Failed to call OpenAI API: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    });\n}\n/**\n * Call OpenAI API with JSON mode enabled for structured output\n * This is used for edit mode to get guaranteed JSON responses\n */\nfunction callOpenAIApiWithJsonMode(messages_1) {\n    return __awaiter(this, arguments, void 0, function* (messages, model = 'gpt-4o-mini-latest') {\n        var _a, _b;\n        const apiKey = (0, secureStorageIpcHandlers_1.getApiKeyForService)('openai');\n        if (!apiKey) {\n            throw new Error('OPENAI_API_KEY not found. Please set it in Settings');\n        }\n        (0, logger_1.log)('OpenAI API Request (JSON mode)', {\n            url: 'https://api.openai.com/v1/chat/completions',\n            model,\n            messageCount: messages.length,\n        });\n        try {\n            const response = yield fetch('https://api.openai.com/v1/chat/completions', {\n                method: 'POST',\n                headers: {\n                    'Authorization': `Bearer ${apiKey}`,\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    messages,\n                    model,\n                    response_format: { type: 'json_object' },\n                }),\n            });\n            (0, logger_1.log)('OpenAI API Response Status (JSON mode)', { status: response.status, statusText: response.statusText });\n            const data = yield response.json();\n            if (!response.ok) {\n                throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);\n            }\n            return ((_b = (_a = data.choices[0]) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.content) || '';\n        }\n        catch (error) {\n            (0, logger_1.logError)('Error calling OpenAI API with JSON mode', error);\n            throw new Error(`Failed to call OpenAI API: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    });\n}\nfunction listOpenAIModels() {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Only use secure storage (no .env fallback)\n        const apiKey = (0, secureStorageIpcHandlers_1.getApiKeyForService)('openai');\n        if (!apiKey) {\n            throw new Error('OPENAI_API_KEY not found. Please set it in Settings');\n        }\n        (0, logger_1.log)('OpenAI List Models Request', { url: 'https://api.openai.com/v1/models' });\n        try {\n            const response = yield fetch('https://api.openai.com/v1/models', {\n                method: 'GET',\n                headers: {\n                    'Authorization': `Bearer ${apiKey}`,\n                },\n            });\n            (0, logger_1.log)('OpenAI List Models Response Status', { status: response.status, statusText: response.statusText });\n            const data = yield response.json();\n            if (!response.ok) {\n                throw new Error(`Failed to list models: ${response.status} ${response.statusText}`);\n            }\n            // Filter to only GPT chat models with -latest suffix\n            return data.data.filter(model => model.id.startsWith('gpt-') && model.id.includes('-latest'));\n        }\n        catch (error) {\n            (0, logger_1.logError)('Error listing OpenAI models', error);\n            throw new Error(`Failed to list models: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    });\n}\nfunction hasApiKey() {\n    // Only check secure storage (no .env fallback)\n    return !!(0, secureStorageIpcHandlers_1.getApiKeyForService)('openai');\n}\n/**\n * Validate an API key by making a test request\n */\nfunction validateApiKey(apiKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            (0, logger_1.log)('OpenAI: Validating API key');\n            const response = yield fetch('https://api.openai.com/v1/models', {\n                method: 'GET',\n                headers: {\n                    'Authorization': `Bearer ${apiKey}`,\n                },\n            });\n            if (!response.ok) {\n                const errorText = yield response.text();\n                (0, logger_1.log)('OpenAI: API key validation failed', { status: response.status, error: errorText });\n                return {\n                    valid: false,\n                    error: response.status === 401 ? 'Invalid API key' : `API error: ${response.statusText}`\n                };\n            }\n            (0, logger_1.log)('OpenAI: API key validated successfully');\n            return { valid: true };\n        }\n        catch (error) {\n            (0, logger_1.logError)('OpenAI: API key validation error', error);\n            return {\n                valid: false,\n                error: `Validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n            };\n        }\n    });\n}\n\n\n//# sourceURL=webpack://markdownplus/./src/main/services/openaiApi.ts?");

/***/ }),

/***/ "./src/main/services/secureStorage.ts":
/*!********************************************!*\
  !*** ./src/main/services/secureStorage.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.loadEncryptedKeys = loadEncryptedKeys;\nexports.setApiKey = setApiKey;\nexports.getApiKey = getApiKey;\nexports.hasApiKey = hasApiKey;\nexports.deleteApiKey = deleteApiKey;\nexports.clearAllApiKeys = clearAllApiKeys;\nexports.isSecureStorageAvailable = isSecureStorageAvailable;\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst path = __importStar(__webpack_require__(/*! path */ \"path\"));\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst logger_1 = __webpack_require__(/*! ../logger */ \"./src/main/logger.ts\");\n/**\n * Secure storage for API keys using Electron's safeStorage API\n * Keys are encrypted using the OS's native credential storage:\n * - Windows: DPAPI (Data Protection API)\n * - macOS: Keychain\n * - Linux: libsecret\n *\n * Encrypted keys are persisted to disk in userData directory\n *\n * Development Override:\n * In development, .env file values take precedence over secure storage.\n * This allows developers to use .env files without storing keys in the system.\n */\nconst API_KEY_PREFIX = 'markdownplus_api_key_';\n// Map provider names to environment variable names\nconst ENV_VAR_MAP = {\n    xai: 'XAI_API_KEY',\n    claude: 'ANTHROPIC_API_KEY',\n    openai: 'OPENAI_API_KEY',\n};\n// In-memory cache of encrypted keys\nconst keyCache = new Map();\n// Path to store encrypted keys\nconst getKeysFilePath = () => {\n    return path.join(electron_1.app.getPath('userData'), 'encrypted-keys.json');\n};\n/**\n * Load encrypted keys from disk on startup\n */\nfunction loadEncryptedKeys() {\n    try {\n        const keysPath = getKeysFilePath();\n        if (!fs.existsSync(keysPath)) {\n            (0, logger_1.log)('Secure Storage: No encrypted keys file found (first run)');\n            return;\n        }\n        const data = fs.readFileSync(keysPath, 'utf-8');\n        const stored = JSON.parse(data);\n        // Convert base64 strings back to Buffers\n        for (const [key, base64Value] of Object.entries(stored)) {\n            if (typeof base64Value === 'string') {\n                keyCache.set(key, Buffer.from(base64Value, 'base64'));\n            }\n        }\n        (0, logger_1.log)('Secure Storage: Loaded encrypted keys from disk', { count: keyCache.size });\n    }\n    catch (error) {\n        (0, logger_1.logError)('Failed to load encrypted keys from disk', error);\n    }\n}\n/**\n * Save encrypted keys to disk\n */\nfunction saveEncryptedKeys() {\n    try {\n        const keysPath = getKeysFilePath();\n        // Convert Buffers to base64 strings for JSON storage\n        const toStore = {};\n        for (const [key, buffer] of keyCache.entries()) {\n            toStore[key] = buffer.toString('base64');\n        }\n        fs.writeFileSync(keysPath, JSON.stringify(toStore, null, 2), 'utf-8');\n        (0, logger_1.log)('Secure Storage: Saved encrypted keys to disk');\n    }\n    catch (error) {\n        (0, logger_1.logError)('Failed to save encrypted keys to disk', error);\n        throw error;\n    }\n}\n/**\n * Store an API key securely\n */\nfunction setApiKey(provider, key) {\n    try {\n        if (!key || key.trim() === '') {\n            throw new Error('API key cannot be empty');\n        }\n        // Encrypt the key using OS credential storage\n        const encrypted = electron_1.safeStorage.encryptString(key);\n        // Store in memory cache\n        const cacheKey = `${API_KEY_PREFIX}${provider}`;\n        keyCache.set(cacheKey, encrypted);\n        // Persist to disk\n        saveEncryptedKeys();\n        (0, logger_1.log)('Secure Storage: API key stored', { provider });\n    }\n    catch (error) {\n        (0, logger_1.logError)(`Failed to store API key for ${provider}`, error);\n        throw error;\n    }\n}\n/**\n * Get an API key (decrypted)\n * In development, checks .env first as an override\n */\nfunction getApiKey(provider) {\n    try {\n        // Development override: Check .env file first\n        const envVarName = ENV_VAR_MAP[provider];\n        const envValue = process.env[envVarName];\n        if (envValue && envValue.trim() !== '') {\n            (0, logger_1.log)('Secure Storage: Using API key from .env (development override)', { provider });\n            return envValue.trim();\n        }\n        // Fall back to secure storage\n        const cacheKey = `${API_KEY_PREFIX}${provider}`;\n        const encrypted = keyCache.get(cacheKey);\n        if (!encrypted) {\n            return null;\n        }\n        // Decrypt the key\n        const decrypted = electron_1.safeStorage.decryptString(encrypted);\n        return decrypted;\n    }\n    catch (error) {\n        (0, logger_1.logError)(`Failed to retrieve API key for ${provider}`, error);\n        return null;\n    }\n}\n/**\n * Check if an API key exists\n * In development, checks .env first as an override\n */\nfunction hasApiKey(provider) {\n    // Development override: Check .env file first\n    const envVarName = ENV_VAR_MAP[provider];\n    const envValue = process.env[envVarName];\n    if (envValue && envValue.trim() !== '') {\n        return true;\n    }\n    // Fall back to secure storage\n    const cacheKey = `${API_KEY_PREFIX}${provider}`;\n    return keyCache.has(cacheKey);\n}\n/**\n * Delete an API key\n */\nfunction deleteApiKey(provider) {\n    try {\n        const cacheKey = `${API_KEY_PREFIX}${provider}`;\n        keyCache.delete(cacheKey);\n        // Persist to disk\n        saveEncryptedKeys();\n        (0, logger_1.log)('Secure Storage: API key deleted', { provider });\n    }\n    catch (error) {\n        (0, logger_1.logError)(`Failed to delete API key for ${provider}`, error);\n        throw error;\n    }\n}\n/**\n * Clear all stored API keys\n */\nfunction clearAllApiKeys() {\n    keyCache.clear();\n    // Persist to disk\n    saveEncryptedKeys();\n    (0, logger_1.log)('Secure Storage: All API keys cleared');\n}\n/**\n * Check if safeStorage is available\n */\nfunction isSecureStorageAvailable() {\n    return electron_1.safeStorage.isEncryptionAvailable();\n}\n\n\n//# sourceURL=webpack://markdownplus/./src/main/services/secureStorage.ts?");

/***/ }),

/***/ "./src/main/services/xaiApi.ts":
/*!*************************************!*\
  !*** ./src/main/services/xaiApi.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_XAI_MODELS = void 0;\nexports.callXAiApi = callXAiApi;\nexports.listModels = listModels;\nexports.hasApiKey = hasApiKey;\nexports.validateApiKey = validateApiKey;\nconst logger_1 = __webpack_require__(/*! ../logger */ \"./src/main/logger.ts\");\nconst secureStorageIpcHandlers_1 = __webpack_require__(/*! ../secureStorageIpcHandlers */ \"./src/main/secureStorageIpcHandlers.ts\");\n// Default models to use if API listing fails\nexports.DEFAULT_XAI_MODELS = [\n    { id: 'grok-3-fast', displayName: 'Grok 3 Fast' },\n    { id: 'grok-3', displayName: 'Grok 3' },\n    { id: 'grok-3-mini', displayName: 'Grok 3 Mini' },\n];\nfunction callXAiApi(messages_1) {\n    return __awaiter(this, arguments, void 0, function* (messages, model = 'grok-3-fast') {\n        var _a, _b;\n        // Only use secure storage (no .env fallback)\n        const apiKey = (0, secureStorageIpcHandlers_1.getApiKeyForService)('xai');\n        if (!apiKey) {\n            throw new Error('XAI_API_KEY not found. Please set it in Settings');\n        }\n        // Format messages for xAI API (support attachments, similar to OpenAI format)\n        const formattedMessages = messages.map(msg => {\n            // If message has attachments, use content array format\n            if (msg.attachments && msg.attachments.length > 0) {\n                const content = [{ type: 'text', text: msg.content }];\n                // Add attachments\n                for (const attachment of msg.attachments) {\n                    if (attachment.type === 'image') {\n                        content.push({\n                            type: 'image_url',\n                            image_url: {\n                                url: `data:${attachment.mimeType};base64,${attachment.data}`,\n                            },\n                        });\n                    }\n                    else if (attachment.type === 'text') {\n                        // Include text files as additional text content\n                        content.push({\n                            type: 'text',\n                            text: `\\n\\n[File: ${attachment.name}]\\n${attachment.data}`,\n                        });\n                    }\n                }\n                return { role: msg.role, content };\n            }\n            // Simple text message\n            return { role: msg.role, content: msg.content };\n        });\n        (0, logger_1.log)('xAI API Request', {\n            url: 'https://api.x.ai/v1/chat/completions',\n            model,\n            messageCount: messages.length,\n        });\n        try {\n            const response = yield fetch('https://api.x.ai/v1/chat/completions', {\n                method: 'POST',\n                headers: {\n                    'Authorization': `Bearer ${apiKey}`,\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    messages: formattedMessages,\n                    model,\n                }),\n            });\n            (0, logger_1.log)('xAI API Response Status', { status: response.status, statusText: response.statusText });\n            const data = yield response.json();\n            if (!response.ok) {\n                throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);\n            }\n            return ((_b = (_a = data.choices[0]) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.content) || 'No response from AI';\n        }\n        catch (error) {\n            (0, logger_1.logError)('Error calling xAI API', error);\n            throw new Error(`Failed to call xAI API: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    });\n}\nfunction listModels() {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Only use secure storage (no .env fallback)\n        const apiKey = (0, secureStorageIpcHandlers_1.getApiKeyForService)('xai');\n        if (!apiKey) {\n            throw new Error('XAI_API_KEY not found. Please set it in Settings');\n        }\n        (0, logger_1.log)('xAI List Models Request', { url: 'https://api.x.ai/v1/models' });\n        try {\n            const response = yield fetch('https://api.x.ai/v1/models', {\n                method: 'GET',\n                headers: {\n                    'Authorization': `Bearer ${apiKey}`,\n                },\n            });\n            (0, logger_1.log)('xAI List Models Response Status', { status: response.status, statusText: response.statusText });\n            const data = yield response.json();\n            if (!response.ok) {\n                throw new Error(`Failed to list models: ${response.status} ${response.statusText}`);\n            }\n            return data.data;\n        }\n        catch (error) {\n            (0, logger_1.logError)('Error listing xAI models', error);\n            throw new Error(`Failed to list models: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    });\n}\nfunction hasApiKey() {\n    // Only check secure storage (no .env fallback)\n    return !!(0, secureStorageIpcHandlers_1.getApiKeyForService)('xai');\n}\n/**\n * Validate an API key by making a test request\n */\nfunction validateApiKey(apiKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            (0, logger_1.log)('xAI: Validating API key');\n            const response = yield fetch('https://api.x.ai/v1/models', {\n                method: 'GET',\n                headers: {\n                    'Authorization': `Bearer ${apiKey}`,\n                },\n            });\n            if (!response.ok) {\n                const errorText = yield response.text();\n                (0, logger_1.log)('xAI: API key validation failed', { status: response.status, error: errorText });\n                return {\n                    valid: false,\n                    error: response.status === 401 ? 'Invalid API key' : `API error: ${response.statusText}`\n                };\n            }\n            (0, logger_1.log)('xAI: API key validated successfully');\n            return { valid: true };\n        }\n        catch (error) {\n            (0, logger_1.logError)('xAI: API key validation error', error);\n            return {\n                valid: false,\n                error: `Validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n            };\n        }\n    });\n}\n\n\n//# sourceURL=webpack://markdownplus/./src/main/services/xaiApi.ts?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "electron":
/*!***************************!*\
  !*** external "electron" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("electron");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "fs/promises":
/*!******************************!*\
  !*** external "fs/promises" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("fs/promises");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main/main.ts");
/******/ 	
/******/ })()
;